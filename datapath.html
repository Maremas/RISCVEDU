<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css?family=Montserrat:400,400i,700"
    />
    <link rel="stylesheet" href="styles.css" />
    <script type="module" src="scripts/setup.js"></script>
    <script type="module" src="scripts/exercises.js"></script>
    <title>RISC-V Processor</title>
  </head>
  <body>
    <nav class="nav">
      <h2>
        <a href="/" class="mainlogo"></a>
      </h2>
      <ul class="navlist">
        <li><a href="pipelining.html">Pipelining</a></li>
        <li><a class="selected" href="datapath.html">Datapath</a></li>
        <li>
          <a href="hazards.html">Hazards</a>
          <ul class="navdropdown">
            <li><a href="structhazards.html">Structural Hazards</a></li>
            <li><a href="datahazards.html">Data Hazards</a></li>
            <li><a href="controlhazards.html">Control Hazards</a></li>
          </ul>
        </li>
      </ul>
    </nav>

    <div class="gridcontainerDatapath">
      <div class="griditemDatapath">
        <h1>Datapath</h1>
        <p>
          To take a closer look on the details of pipelining and the handling of
          ocurring constraints, we from here on use a subset of the RISC-V
          instruction set, containing the following 7 instructions:
        </p>
        <ul>
          <li>load word (lw)</li>
          <li>store word (sw)</li>
          <li>add (add)</li>
          <li>subtract (sub)</li>
          <li>AND (and)</li>
          <li>OR (or)</li>
          <li>branch if equal (beq)</li>
        </ul>
        <a class="annotation">
          If you are not familiar with these RISC-V instructions and what they
          do, look it up before continuing.
        </a>
        <h2>Pipeline Stages</h2>
        In the pipelining introduction we viewed at the pipeline stages
        abstractly as steps in the instruction execution. Here we take a closer
        look at those pipeline stages. The diagram not only depicts the stage
        order but is an abstraction of the processor datapath with its
        components. We can see that every separated component is only depicted
        once, except for the <b>Reg</b>ister. This is not only due to the stage
        order, but really is the order in which an instruction, once decoded,
        flows through the processor. Every instruction passes through the
        components instruction memory, register, ALU, data memory and register
        in the same order.<br /><br />
        The 5 pipeline stages align with the 5 main components of the
        datapath:<br /><br />

        <b>Instruction fetch (IF)</b><br />
        This step fetches the instruction from the instruction memory
        (<b>InstrMem</b>).<br /><br />

        <b>Instruction decode and register fetch (ID)</b><br />
        The instruction is decoded and values are read from registers if needed.
        We can read two registers at once, therefore two output wires from
        <b>Reg</b>.<br /><br />

        <b>Execution, memory address computation or branch completion (EX)</b>
        <br />
        The ALU is operating on up to two (therefore 2 input wires) previously
        prepared operands from the previous step. It performs one of three
        functions depending on the instruction type.<br />
        <ol>
          <li>
            Memory reference <br />
            Adding operands to calculate a data memory address.
          </li>
          <br />
          <li>
            Arithmetic-logical instruction <br />
            Performing an operation specified by the instruction code on the two
            values prepared by the previous stage.
          </li>
          <br />
          <li>
            Branch <br />
            Equal comparison between the two registers prepared by the previous
            step. Output signal determines whether to branch or not to branch.
          </li>
        </ol>

        <b>Memory access (MEM)</b><br />
        instructions which write or read access the data memory (DataMem) and
        read or write a value to / from the adress calculated by the ALU. Other
        instructions bypass the data memory.<br /><br />

        <b>Write back to register (WB)</b><br />
        The instruction writes a value, e. g. the result of an addition, to the
        destination register adress, if needed.
      </div>
      <div class="griditemDatapath">
        For example, we can look at the instruction <b> add </b> from the RISC-V
        instruction set. <br />
        The following instruction adds the values stored at registers x1 and x2
        and stores them to x3. It uses the following elements and connection
        wires of the datapath:
      </div>
      <div class="griditemDatapath pipelinediagram instrR add x3 x1 x2"></div>
      <div class="annotation griditemDatapath">
        <b>What do the colors in the diagram stand for?</b><br />
        Every instruction uses different components of the processor hardware.
        The blue color shows the path every instruction takes.<br />
        If a wire is colored, it is used by the instruction. If a processor
        component is used, it is colored: if the left half is colored, there is
        a
        <b>write</b> interaction within the stage. If the right half is colored,
        there is a <b>read</b> interaction within the stage. <br />
        The pipeline registers between the components are always colored, since
        they are used regardless of the instruction type.
      </div>
      <div class="griditemDatapath">
        <b>Clock cycle length and write and read operations</b><br />
        As we mentioned before, every clock cycle has to be as long as the
        longest stage execution takes. If this would not be the case, we can not
        ensure, that e. g. a memory operation is finished before in the next
        clock cycle an instruction wants to read from this part of the memory.
        This limits the maximum clock cycle frequency, but ensures correct
        execution of the parallelized code, which can itself have more weight
        than the limitations in clock cycle frequency in regards to efficiency
        and reliability.
        <br /><br />
        As we have seen before, the pipeline stages are aligned with the
        processor components. So every component should only occur once, since
        we do not want to have conflicts between stages executed simultaneously.
        This is not the case for the register (Reg), which occurs twice in the
        diagram. The write obviously has to take place after execution, but why
        can we further have write and read in the same instruction? The answer
        is simple: the write and read operation only need maximum half a clock
        cycle of time. Instead of leaving the register idle for the remainder of
        a clock cycle, we allow the component to be read and written to in the
        same cycle: write takes place in the first half of the cycle, read in
        the second. This not only allows it to execute register access
        parallelized: we can even read the same value, stored in the first half
        of the clock cycle, in the second half without worrying about a
        conflict.
        <br /><br />

        example: Consider a scenario where the stages have different time
        requirements: IF: 2 ns ID: 3 ns EX: 4 ns MEM: 5 ns WB: 1 ns Here, the
        MEM stage is the longest, taking 5 nanoseconds. If the clock cycle were
        shorter than 5 ns, say 4 ns, the MEM stage wouldn't reliably complete in
        one cycle, leading to errors.
      </div>
      <div class="griditemDatapath exercise">
        Which components and connections of the datapath are used by the
        following instructions?
        <br />
        Click on the processor components and pipelines registers to toggle them
        as a whole as active (colored) or inactive (not colored).
        <br />
        <div id="colorByClick" class="pipelinediagram lw"></div>
        <button id="colorByClickSubmit" type="button">Submit</button>
        <div id="coloringFeedback" class="feedback"></div>
      </div>
      <div class="griditemDatapath">
        <form id="selectInstructionForm">
          <label for="instructionOptions">Choose an instruction:</label>
          <select name="instructions" id="instructionOptions">
            <option value="onlyReg">---</option>
          </select>
        </form>
        <div id="coloredsvg" class="pipelinediagram"></div>
      </div>
      <div class="griditemDatapath">
        <a href="/pipelining.html" class="previous">&laquo; Introduction</a>
        <a href="/hazards.html" class="next">Hazards &raquo;</a>
      </div>
    </div>
    <footer>
      Copyright &#169; 2024
      <a href="https://github.com/Maremas/RISCVEDU"
        >Tim Gaisbauer, Marius Henrich</a
      >
    </footer>
    <noscript
      >This website needs JavaScript to be enabled to work properly. Please
      enable JavaScript in your browser.
    </noscript>
  </body>
</html>
