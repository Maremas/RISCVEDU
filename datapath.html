<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css?family=Montserrat:400,400i,700"
    />
    <link rel="stylesheet" href="styles.css" />
    <script type="module" src="scripts/setup.js"></script>
    <script type="module" src="scripts/exercises.js"></script>
    <title>RISC-V Processor</title>
  </head>
  <body>
    <nav class="nav">
      <h2>
        <a href="/" class="mainlogo"></a>
      </h2>
      <ul class="navlist">
        <li><a href="pipelining.html">Pipelining</a></li>
        <li><a class="selected" href="datapath.html">Datapath</a></li>
        <li>
          <a href="hazards.html">Hazards</a>
          <ul class="navdropdown">
            <li><a href="structhazards.html">Structural Hazards</a></li>
            <li><a href="datahazards.html">Data Hazards</a></li>
            <li><a href="controlhazards.html">Control Hazards</a></li>
          </ul>
        </li>
      </ul>
    </nav>

    <div class="gridcontainerDatapath">
      <div class="griditemDatapath">
        <h1>Datapath</h1>
        <p>
          To take a closer look on the details of pipelining and the handling of
          ocurring constraints, we from here on use a subset of the RISC-V
          instruction set, containing the following 7 instructions:
        </p>
        <ul>
          <li>load word (lw)</li>
          <li>store word (sw)</li>
          <li>add (add)</li>
          <li>subtract (sub)</li>
          <li>AND (and)</li>
          <li>OR (or)</li>
          <li>branch if equal (beq)</li>
        </ul>
        <a class="annotation">
          If you are not familiar with these RISC-V instructions and how they
          work, look it up before continuing.
        </a>
        <h2>Stage description</h2>
        <b>Instruction fetch</b><br />
        This step fetches the instruction from the memory and computes the
        address of the following instruction.<br /><br />

        <b>Instruction decode and register fetch</b><br />
        In this step, as well as the first one, we do not yet know what the
        instruction is. With that in mind, we can only perform actions that are
        either applicable to all instructions or not harmful to them. Because of
        that we can read two registers at once, even if that is not
        necessary.<br /><br />

        <b>Execution, memory address computation or branch completion</b>
        <br />
        In this step, the datapath operation is determined by the instruction
        class. The ALU is operating on the prepared operands from the previous
        step. It performs one of three functions depending on the instruction
        class.<br />
        <ul>
          <li>
            1) Memory reference <br />
            Adding operands to form memory address.
          </li>
          <br />
          <li>
            2) Arithmetic-logical instruction (R-type) <br />
            Performing an operation specified by opcode on the two values read
            from the register file in the previous cycle.
          </li>
          <br />
          <li>
            3) Branch <br />
            Equal comparison between the two registers read in the previous
            step. Zero signal is used to determine whether to branch or not to
            branch.
          </li>
        </ul>

        <b>Memory access</b><br />
        Read or write instruction accesses memory and an arithmetic-logical
        instruction writes its results. The value is stored into the memory data
        register, which must be used in the next clock cycle.<br /><br />

        <b>Write back to register</b><br />
        During this step, read data which was stored in the memory data register
        is completed by writing back the value into the register file.
      </div>
      <div class="griditemDatapath">
        For example, we can look at the instruction <b> add </b> from the RISC-V
        instruction set. <br />
        The instruction uses the following elements of the RISC-V datapath:
      </div>
      <div class="griditemDatapath pipelinediagram instrR add"></div>
      <div class="annotation griditemDatapath">
        <b>What do the colors in the diagram stand for?</b><br />
        Every instruction uses different components of the processor hardware.
        The blue color shows the path every instruction takes.<br />
        If a wire is colored, it is used by the instruction. If a processor
        component is used, it is colored: if the left half is colored, there is
        a
        <b>write</b> interaction within the stage. If the right half is colored,
        there is a <b>read</b> interaction within the stage. <br />
        The pipeline registers between the components are always colored, since
        they are used regardless of the instruction type.
      </div>
      <div class="griditemDatapath">
        <b>Clock cycle length and write and read operations</b><br />
        Every clock cycle has to be as long as the longest stage execution
        takes. Since we want to benefit from parallelization, we need to ensure
        that every operation finishes within a designed clock cycle unit. If ths
        would not be the case, we can not ensure, that e. g. a memory operation
        is finished before in the next clock cycle an instruction wants to read
        from this part of the memory. this limits the maximum clock cycle
        frequency, but ensures correct execution of the parallelized code, which
        can itself have more weight than the limitations in clock cycle
        frequency in regards to efficiency and reliability. Another benefit
        comes from the design decision to split the mem write and read stages in
        half: the write and read operation only need maximum half a clock cycle
        of time, and write takes plaec in the first half of its cycle, read in
        the second half. This allows it to execute memory access parallelized:
        if within the same clock cycle a read (ID stage) and write (WB Stage) is
        performed, we can make sure there is no conflict happening between those
        operations. We therefore do not have to worry about instruction
        sequences having both of them in the same clock cycle.<br />
        example: Consider a scenario where the stages have different time
        requirements: IF: 2 ns ID: 3 ns EX: 4 ns MEM: 5 ns WB: 1 ns Here, the
        MEM stage is the longest, taking 5 nanoseconds. If the clock cycle were
        shorter than 5 ns, say 4 ns, the MEM stage wouldn't reliably complete in
        one cycle, leading to errors.
      </div>
      <div class="griditemDatapath exercise">
        Which components and connections of the datapath are used by the
        following instructions?
        <br />
        Click on the processor components and pipelines registers to toggle them
        as a whole as active (colored) or inactive (not colored).
        <br />
        <div id="colorByClick" class="pipelinediagram lw"></div>
        <button id="colorByClickSubmit" type="button">Submit</button>
        <div id="coloringFeedback" class="feedback"></div>
      </div>
      <div class="griditemDatapath">
        <form id="selectInstructionForm">
          <label for="instructionOptions">Choose an instruction:</label>
          <select name="instructions" id="instructionOptions">
            <option value="onlyReg">---</option>
          </select>
        </form>
        <div id="coloredsvg" class="pipelinediagram"></div>
      </div>
      <div class="griditemDatapath">
        <a href="/pipelining.html" class="previous">&laquo; Introduction</a>
        <a href="/hazards.html" class="next">Hazards &raquo;</a>
      </div>
    </div>
    <footer>
      Copyright &#169; 2024
      <a href="https://github.com/Maremas/RISCVEDU"
        >Tim Gaisbauer, Marius Henrich</a
      >
    </footer>
    <noscript
      >This website needs JavaScript to be enabled to work properly. Please
      enable JavaScript in your browser.
    </noscript>
  </body>
</html>
