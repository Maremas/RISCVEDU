<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <!--include the following meta tag to make chrome dev tools recognize media queries: -->
    <meta name="viewport" content="width=device-width" />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css?family=Montserrat:400,400i,700"
    />
    <!-- font -->
    <link rel="stylesheet" href="styles.css" />
    <script type="text/javascript" src="script.js"></script>
    <title>RISC-V Processor</title>
  </head>
  <body>
    <nav class="nav">
      <h2>
        <a href="/" class="mainlogo"></a>
      </h2>
      <ul class="navlist">
        <li><a href="pipelinediagrams.html">Pipeline Diagrams</a></li>
        <li><a href="datapath.html">Datapath</a></li>
        <li>
          <a href="hazards.html">Hazards</a>
          <ul class="navdropdown">
            <li><a href="structhazards.html">Structural Hazards</a></li>
            <li><a href="datahazards.html">Data Hazards</a></li>
            <li><a href="controlhazards.html">Control Hazards</a></li>
          </ul>
        </li>
        <li><a href="simulation.html"> Multicycle Simulation</a></li>
      </ul>
    </nav>
    <h1>Introduction to Pipelining</h1>
    
    <h2>What is pipelining?</h2>

    <p> Pipelining is a method of implementation where multiple instructions are executed concurrently by overlapping them. <br>
      This is done to improve efficiency, performance, and time consumption by breaking down a task into smaller, independent stages. <br>
      Nowadays, pipelining is almost universally adopted.
    </p>

    <h2>Why is pipelining useful?</h2>

    <p>
      Imagine a routine, like doing laundry, with 4 stages while every stage needs the same time to be completed.
      <ul>
        <li>Place dirty laundry in washer</li>
        <li>When washer is finished, place laundry in dryer</li>  
        <li>When dryer is finished, place laundry on table to fold</li>  
        <li>When folding is finished, put clothes away</li>  
      </ul>
      This routine takes a fixed time, because all stages can only proceed if the one before is completed.<br><br><br>

      Placeholder for Figure 4.27, page 284 from the book. -> Put it to the right?<br><br>
    </p>

    <p>
      With pipelining, the total time to complete the routine once will not decrease.<br>
      Anyhow the throughput can be increased by starting the routine a second time if it is possible to initiate the first step again. <br>
      This can just happen if there are separate resources for each stage. <br>
      This means, that by overlapping the different stages, the efficiency in the laundry process can be maximized, which ensures a smoother workflow and quicker time being done washing clothes.
    </p>

    <p>
      The speed-up due to pipelining is equal to the number of stages in the pipeline if all stages take about the same time and there is enough work to do.<br>
      This means pipelined laundry is potentially four times faster than non-pipelined.<br>
      20 loads pipelined take about five times as long as one load, while 20 sequential loads would take 20 times as long as one load.
    </p>

    <h2>Pipelining applied to processors</h2>

    <p>
      In processors we pipeline instruction execution. We are taking a closer look on RISC-V pipelining with the following 5 stages:
      <ul>
          <li>Fetch instruction from memory</li>
          <li>Read registers and decode the instruction</li>
          <li>Execute the operation or calculate an address</li>
          <li>Access an operand in data memory (if necessary)</li>
          <li>Write the result into a register (if necessary)</li>
      </ul>
    </p>

    <p>
      By having those 5 stages, we can now take a closer look on how the pipeline works and show that this method speeds up the instruction
      execution just like it speeds up doing laundry. 
    </p>

    <h2>Difference between single-cycle and pipelined performance</h2>

    <p>
      To take a closer look on the difference between single-cycle and pipelined performance, we create a pipeline with the following 7 instructions:
      <ul>
        <li>load word (lw)</li>
        <li>store word (sw)</li>
        <li>add (add)</li>
        <li>subtract (sub)</li>
        <li>AND (and)</li>
        <li>OR (or)</li>
        <li>branch if equal (beq)</li>
      </ul>
    </p>

    <p>
      For convenience, we first assume that all stages in the pipeline take the same amount of time (200ps) to be processed.<br>
      With this information, we can now take a closer look at the stages needed for the different instructions.
    </p>

    <p>
      A <b>single-cycle design</b> must always allow time for the slowest instruction because every instruction takes exactly one clock cycle. <br>
      In our case this (lw) - 1000ps. For 3 load-instructions this means the time between the first and fourth instruction is 3x1000=3000 ps. 
    </p>

    <p>
      If we now take a closer look at the same 3 load-instructions in a <b>pipeline-design</b>, the time between the first and fourth instruction is just 3x200=600 ps.<br>
      This difference results from the fact that the pipelined clock-cycle has the worst-case clock cycle of 200ps.
      (Again, this is because we assume the same amount of time for every stage, although some could be faster) 
    </p>

    <p>
      The pipelining speed-up can be turned into a formula. If all stages take the same amount of time, the formula is equal to:
    </p>

    <p> 
      time between instructions<sub>pipelined</sub> = <span class="frac"><sup>time between instructions<sub>non-pipelined</sub></sup> <span>/</span> <sub>number of pipe stages</sub></span>
    </p>

    <p>
      This means that under ideal conditions and with many instructions, the speed-up is approximately equal to the number of pipe stages. <br>
      ðŸ¢‚ A five-stage pipeline is nearly five times faster than a single-cycle nonpipelined execution.
    </p>

    <p>
      This can be shown by adding a large number of instructions to the total execution time for our non-pipelined (3000ps) and pipelined (1600ps) examples. <br>
      If we add 1,000,000 instructions to both examples, we get a total execution time of 1,000,000x1000ps+3000ps=1,000,003,000ps for the single-cycle design,
      while the pipeline just takes a total execution time of 1,000,000*200ps+1600ps=200,001,600ps.
    </p>

    <p>
      Under these perfect conditions, the ratio of total execution time is close to the ratio of times between instructions:<br><br>
    
      <span class="frac"><sup>1,000,003,000ps</sub></sup> <span>/</span> <sub>200,001,600ps</sub></span> â‰… <span class="frac"><sup>1,000ps</sub></sup> <span>/</span> <sub>200ps</sub></span> â‰… 5.00
    </p>

    <p>
      Overall pipelining improves the performance by increasing instruction throughput, in contrast to decreasing the execution time of an individual instruction, but instruction throughput is the important metric because of the billions of instructions real programs execute.
    </p>


    <footer>
      <p>Copyright &#169; 2024 <a href="/">My Site</a></p>
    </footer>
  </body>
</html>
