<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css?family=Montserrat:400,400i,700"
    />
    <link rel="stylesheet" href="styles.css" />
    <script src="script.js"></script>
    <title>RISC-V Processor</title>
  </head>
  <body>
    <nav class="nav">
      <h2>
        <a href="/" class="mainlogo"></a>
      </h2>
      <ul class="navlist">
        <li><a href="pipelinediagrams.html">Pipeline Diagrams</a></li>
        <li><a href="datapath.html">Datapath</a></li>
        <li>
          <a href="hazards.html">Hazards</a>
          <ul class="navdropdown">
            <li><a href="structhazards.html">Structural Hazards</a></li>
            <li>
              <a class="selected" href="datahazards.html">Data Hazards</a>
            </li>
            <li><a href="controlhazards.html">Control Hazards</a></li>
          </ul>
        </li>
      </ul>
    </nav>

    <h1>Data Hazards</h1>
    <div class="gridcontainerdata">
      <div class="datagriditem"><b>Data Hazards</b>
        <p>
          A data hazard occurs when a pipeline must be stalled because one step must wait for another one to complete. 
          A planned instruction can not execute in the proper clock cycle because the data needed to execute the following instruction are not yet available.
        </p>
        <p>
          If we look at a example from doing the laundry again, a data hazard could be the following. You find a Sock without match while you are folding the dry laundry.
          One strategy could be running to your room to search for a matching sock. While you are doing that, the drying laundry will be ready to be folded, 
          the washed laundry will be ready to be put into the dryer and a new load could be put into the washer.
        </p>
        <p>
          In a processor pipeline, data hazards arise from the dependece of one instruction on an earlier one that is still in the pipeline.
          If we for example have an add instruction followed directly by a subtract instruction which uses the sum of the previous instruction.
          <ul>
            <li>add x19, x0, x1</li>
            <li>sub x2, x19, x3</li>
          </ul>
          The add instruction does not write its result until the fifth stage of the pipeline, so we would waste 3 clock cycles by waiting for this to happen.
        </p>
        <p>
          The solution for data hazards is called <b>forwarding</b> or <b>bypassing</b>. <br>
          It is a method of resolving a data hazard by retrieving the missing data element from internal buffers rather than waiting for it to arrive from programmer-visible 
          registers or memory. <br>
          An example for this is that as soon as the ALU creates the sum for the add, we can supply it as an input for the subtract. This is done by adding extra hardware to retrieve the missing 
          item early from the internal resources.
        </p>
      </div>
      <div id="exercisecontainer" class="datagriditem exercise">
        <b> exercise about forwarding by drawing stage connections</b> <br />
        For the two instructions above, show what pipeline stages would be
        connected by forwarding. Use the drawing in Figure 4.30 to represent the
        datapath during the five stages of the pipeline. Align a copy of the
        datapath for each instruction, similar to the laundry pipeline in Figure
        4.27. Figure 4.31 shows the connection to forward the value in x1 after
        the execution stage of the add instruction as input to the execution
        stage of the sub instruction.
        <b
          >Exercise: solve through stalling first, then reordering, then
          forwarding whilst comparing cpi of all of them
        </b>
        <br />
        lw x1, 0(x31) // load a<br />
        lw x2, 8(x31) // load b <br />
        add x3, x1, x2 // a + b <br />
        sw x3, 24(x31) // store (a + b) <br />
        lw x4, 16(x31) // load c <br />
        add x5, x1, x4 // a + c <br />
        sw x5, 32(x31) // store (a + c) <br />
        <br />
        first part: eliminate hazards by stalling<br />
        second part: reorder to solve load-use hazards <br />
        third part: eliminate hazards other than load-use by forwarding<br />
        <table>
          <tbody id="exampleLeft">
            <tr>
              <td class="bubble bubblesvg" colspan="5"></td>
            </tr>
          </tbody>
        </table>
        <table id="pipelineTable">
          <thead>
            <tr>
              <th>CC 1</th>
              <th>CC 2</th>
              <th>CC 3</th>
              <th>CC 4</th>
              <th>CC 5</th>
              <th>CC 6</th>
              <th>CC 7</th>
              <th>CC 8</th>
              <th>CC 9</th>
              <th>CC 10</th>
              <th>CC 11</th>
            </tr>
          </thead>
          <tbody id="exampleRight">
            <tr>
              <td class="tinted pipelinediagram lw" colspan="5"></td>
              <td class="nodroptarget" colspan="6"></td>
            </tr>
            <tr>
              <td class="nodroptarget"></td>
              <td class="tinted pipelinediagram lw" colspan="5"></td>
              <td class="nodroptarget" colspan="5"></td>
            </tr>
            <tr>
              <td class="nodroptarget" colspan="2"></td>
              <td class="tinted pipelinediagram add" colspan="5"></td>
              <td class="nodroptarget" colspan="4"></td>
            </tr>
            <tr>
              <td class="nodroptarget" colspan="3"></td>
              <td class="tinted pipelinediagram sw" colspan="5"></td>
              <td class="nodroptarget" colspan="3"></td>
            </tr>
            <tr>
              <td class="nodroptarget" colspan="4"></td>
              <td class="tinted pipelinediagram lw" colspan="5"></td>
              <td class="nodroptarget" colspan="2"></td>
            </tr>
            <tr>
              <td class="nodroptarget" colspan="5"></td>
              <td class="tinted pipelinediagram add" colspan="5"></td>
              <td class="nodroptarget" colspan="1"></td>
            </tr>
            <tr>
              <td class="nodroptarget" colspan="6"></td>
              <td class="tinted pipelinediagram sw" colspan="5"></td>
            </tr>
          </tbody>
        </table>
        <script src="Sortable.js"></script>
        <script>
          new Sortable(exampleLeft, {
            group: {
              name: "shared",
              pull: "clone",
              put: true, // Do not allow items to be put into this list
            },
            animation: 200,
            sort: false, // To disable sorting: set sort to false
            onAdd: function (evt) {
              evt.item.remove();
            },
          });
    
          new Sortable(exampleRight, {
            group: "shared",
            animation: 200,
            filter: ".tinted",
            onSort: function (evt) {
              adaptTable();
            },
          });
    
          function adaptTable(rowOfBubble) {
            newtable = document.createElement("table");
            const table = document.getElementById("pipelineTable");
            const num_rows = table.rows.length - 1; //because of the header row
            const needed_cols = num_rows + 4;
    
            const originalHead = table.getElementsByTagName("thead")[0];
            const header = document.createElement("th");
            const headrow = document.createElement("tr");
            for (let col = 1; col <= needed_cols; col++) {
              const th = document.createElement("th");
              th.innerHTML = "CC " + col;
              headrow.appendChild(th);
            }
            header.appendChild(headrow);
            originalHead.innerHTML = header.innerHTML;
    
            const body = document.createElement("tbody");
            const originalBody = document.getElementById("exampleRight");
    
            for (let current_row = 1; current_row <= num_rows; current_row++) {
              const row = document.createElement("tr");
    
              const offsetBefore = document.createElement("td");
              offsetBefore.classList.add("offsetBefore");
              const colspanBefore = current_row - 1;
              offsetBefore.setAttribute("colspan", colspanBefore);
              if (colspanBefore > 0) {
                row.appendChild(offsetBefore);
              }
    
              const cells = table.rows[current_row].getElementsByTagName("td");
              for (let i = 0; i < cells.length; i++) {
                const cell = cells[i];
                if (
                  cell.classList.contains("pipelinediagram") ||
                  cell.classList.contains("bubblesvg")
                ) {
                  cell.setAttribute("colspan", 5);
                  row.appendChild(cell);
                }
              }
    
              const offsetAfter = document.createElement("td");
              offsetAfter.classList.add("offsetAfter");
              const colspanAfter = num_rows - current_row;
              offsetAfter.setAttribute("colspan", colspanAfter);
              if (colspanAfter > 0) {
                row.appendChild(offsetAfter);
              }
              body.appendChild(row);
            }
            originalBody.innerHTML = body.innerHTML;
          }
        </script>
      </div>
    </div>
    <footer>
      <p>Copyright &#169; 2024 <a href="/">My Site</a></p>
    </footer>
  </body>
</html>
