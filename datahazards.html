<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css?family=Montserrat:400,400i,700"
    />
    <link rel="stylesheet" href="styles.css" />
    <script type="module" src="script.js"></script>
    <title>RISC-V Processor</title>
  </head>
  <body>
    <nav class="nav">
      <h2>
        <a href="/" class="mainlogo"></a>
      </h2>
      <ul class="navlist">
        <li><a href="pipelinediagrams.html">Pipeline Diagrams</a></li>
        <li><a href="datapath.html">Datapath</a></li>
        <li>
          <a href="hazards.html">Hazards</a>
          <ul class="navdropdown">
            <li><a href="structhazards.html">Structural Hazards</a></li>
            <li>
              <a class="selected" href="datahazards.html">Data Hazards</a>
            </li>
            <li><a href="controlhazards.html">Control Hazards</a></li>
          </ul>
        </li>
      </ul>
    </nav>

    <h1>Data Hazards</h1>
    <div class="gridcontainerdata">
      <div class="datagriditem">
        <b>Data Hazards</b>
        <p>
          A data hazard occurs when a pipeline must be stalled because one step
          must wait for another one to complete. A planned instruction can not
          execute in the proper clock cycle because the data needed to execute
          the following instruction are not yet available.
        </p>
        <p>
          If we look at a example from doing the laundry again, a data hazard
          could be the following. You find a Sock without match while you are
          folding the dry laundry. One strategy could be running to your room to
          search for a matching sock. While you are doing that, the drying
          laundry will be ready to be folded, the washed laundry will be ready
          to be put into the dryer and a new load could be put into the washer.
        </p>
        <p>
          In a processor pipeline, data hazards arise from the dependece of one
          instruction on an earlier one that is still in the pipeline. If we for
          example have an add instruction followed directly by a subtract
          instruction which uses the sum of the previous instruction.
        </p>
        <ul>
          <li>add x19, x0, x1</li>
          <li>sub x2, x19, x3</li>
        </ul>
        <p>
          The add instruction does not write its result until the fifth stage of
          the pipeline, so we would waste 3 clock cycles by delaying the
          execution of sub until the result of add is written into the register.
        </p>
        <div id="exercisecontainer" class="datagriditem exercise">
          (first part: eliminate hazards by stalling) <br />
          To visualize this hazard type, consider you want to perform the
          operation <b>a + b</b> on a RISC-V processor. This can be achieved by
          the following instruction sequence:<br />
          <br />
          lw x1, 0(x31) // load a<br />
          lw x2, 8(x31) // load b <br />
          add x3, x1, x2 // a + b <br />
          sw x3, 24(x31) // store (a + b) <br />
          <br />
          Insert stalls ("bubbles") wherever they are needed in the instruction
          pipeline below.
          <table id="bubbleTable">
            <tbody id="bubbleTableBody">
              <tr id="bubbleTableRow">
                <td class="bubble bubblesvg" colspan="5"></td>
              </tr>
            </tbody>
            <tr id="bubbleTableDummyRow">
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
              <td></td>
            </tr>
          </table>
          <table id="stallTable">
            <thead>
              <tr>
                <th>CC 1</th>
                <th>CC 2</th>
                <th>CC 3</th>
                <th>CC 4</th>
                <th>CC 5</th>
                <th>CC 6</th>
                <th>CC 7</th>
                <th>CC 8</th>
              </tr>
            </thead>
            <tbody id="stallTableBody">
              <tr>
                <td class="notSortable pipelinediagram instrI2 lw x1 0(x31)" colspan="5"></td>
                <td class="nodroptarget" colspan="3"></td>
              </tr>
              <tr>
                <td class="nodroptarget"></td>
                <td class="notSortable pipelinediagram instrI2 lw x2 8(x31)" colspan="5"></td>
                <td class="nodroptarget" colspan="2"></td>
              </tr>
              <tr>
                <td class="nodroptarget" colspan="2"></td>
                <td class="notSortable pipelinediagram instrR add x3 x1 x2" colspan="5"></td>
                <td class="nodroptarget" colspan="1"></td>
              </tr>
              <tr>
                <td class="nodroptarget" colspan="3"></td>
                <td class="notSortable pipelinediagram instrS sw x3 24(x31)" colspan="5"></td>
              </tr>
            </tbody>
          </table>
          <input id="stallFormButton" type="button" value="Submit" />
          <div id="stallFeedback" class="feedback"></div>
        </div>
        <br>
          Another possible way of solving data hazards is called
          <b>forwarding</b> or <b>bypassing</b>. <br />
          It is a method of resolving a data hazard by retrieving the missing
          data from internal buffers rather than waiting for it to arrive from
          (programmer-visible) registers or memory. <br />
          These buffers are called pipeline registers and are written to at the
          end of every clock cycle and can be read from as input in the
          following clock cycle. Afterwards they are overwritten by new data
          from the following clock cycle. Reconsider our example from above: an
          ADD instruction followed by a SUB instruction. Through stalling, the
          sub instruction is delayed until the sum of the ADD is written to the
          data register and therefore accessbile for the following instruction.
          With pipeline registers it is available right after the CC in which
          the ALU calculates the sum and stores it in a pipeline register. The
          sub instruction can access this pipeline register as an input for its
          calculation instead of waiting until it is available in the data
          register. </br>
          As we can see, this method is more efficient than stalling, since it makes the 3 stall cycles obsolete. 
          It comes with the need to implement additional control logic that can determine where an input is read from, but leads to a considerably high performance increase.
        </p>
      </div>
      <div id="forwardExerciseContainer" class="datagriditem exercise">
        <b> exercise about forwarding by drawing stage connections</b> <br />
        For the two instructions above, show what pipeline stages would be
        connected by forwarding. 
        <table id="forwardExerciseTable">
          <thead>
            <tr>
              <th>CC 1</th>
              <th>CC 2</th>
              <th>CC 3</th>
              <th>CC 4</th>
              <th>CC 5</th>
              <th>CC 6</th>
              <th>CC 7</th>
              <th>CC 8</th>
            </tr>
          </thead>
          <tbody id ="forwardExerciseTableBody">
            <svg id="forwardLines" viewBox="0 0 592 240" preserveAspectRatio ="none" ></svg>
            <tr>
              <td class="pipelinediagram instrI2 lw x1 0(x31)" colspan="5"></td>
              <td class="nodroptarget" colspan="3"></td>
            </tr>
            <tr>
              <td class="nodroptarget"></td>
              <td class="pipelinediagram instrI2 lw x2 8(x31)" colspan="5"></td>
              <td class="nodroptarget" colspan="2"></td>
            </tr>
            <tr>
              <td class="nodroptarget" colspan="2"></td>
              <td class="pipelinediagram instrR add x3 x1 x2" colspan="5"></td>
              <td class="nodroptarget" colspan="1"></td>
            </tr>
            <tr>
              <td class="nodroptarget" colspan="3"></td>
              <td class="pipelinediagram instrS sw x3 24(x31)" colspan="5"></td>
            </tr>
          </tbody>
        </table>

        Use the drawing in Figure 4.30 to represent the
        datapath during the five stages of the pipeline. Align a copy of the
        datapath for each instruction, similar to the laundry pipeline in Figure
        4.27. Figure 4.31 shows the connection to forward the value in x1 after
        the execution stage of the add instruction as input to the execution
        stage of the sub instruction.
        <b
          >Exercise: solve through stalling first, then reordering, then
          forwarding whilst comparing cpi of all of them
        </b>
        <br />
        lw x1, 0(x31) // load a<br />
        lw x2, 8(x31) // load b <br />
        add x3, x1, x2 // a + b <br />
        sw x3, 24(x31) // store (a + b) <br />
        lw x4, 16(x31) // load c <br />
        add x5, x1, x4 // a + c <br />
        sw x5, 32(x31) // store (a + c) <br />
        <script src="Sortable.js"></script>
        <script>
          new Sortable(bubbleTableBody, {
            group: {
              name: "shared",
              pull: "clone",
              put: true, // Do not allow items to be put into this list
            },
            animation: 200,
            sort: false, // To disable sorting: set sort to false
            onAdd: function (evt) {
              evt.item.remove();
            },
          });

          new Sortable(stallTableBody, {
            group: "shared",
            animation: 200,
            filter: ".notSortable",
            onSort: function (evt) {
              adaptTable();
            },
          });

          function adaptTable(rowOfBubble) {
            newtable = document.createElement("table");
            const table = document.getElementById("stallTable");
            const num_rows = table.rows.length - 1; //because of the header row
            const needed_cols = num_rows + 4;

            const originalHead = table.getElementsByTagName("thead")[0];
            const header = document.createElement("th");
            const headrow = document.createElement("tr");
            for (let col = 1; col <= needed_cols; col++) {
              const th = document.createElement("th");
              th.innerHTML = "CC " + col;
              headrow.appendChild(th);
            }

            header.appendChild(headrow);
            originalHead.innerHTML = header.innerHTML;

            const bubbleTableDummyRow = document.getElementById("bubbleTableDummyRow");
            for (let col = 0; col < needed_cols - bubbleTableDummyRow.cells.length; col++) {
              const td = document.createElement("td");
              bubbleTableDummyRow.appendChild(td);
            }

            const body = document.createElement("tbody");
            const originalBody = document.getElementById("stallTableBody");

            for (let current_row = 1; current_row <= num_rows; current_row++) {
              const row = document.createElement("tr");

              const offsetBefore = document.createElement("td");
              offsetBefore.classList.add("offsetBefore");
              const colspanBefore = current_row - 1;
              offsetBefore.setAttribute("colspan", colspanBefore);
              if (colspanBefore > 0) {
                row.appendChild(offsetBefore);
              }

              const cells = table.rows[current_row].getElementsByTagName("td");
              for (let i = 0; i < cells.length; i++) {
                const cell = cells[i];
                if (
                  cell.classList.contains("pipelinediagram") ||
                  cell.classList.contains("bubblesvg")
                ) {
                  cell.setAttribute("colspan", 5);
                  row.appendChild(cell);
                }
              }

              const offsetAfter = document.createElement("td");
              offsetAfter.classList.add("offsetAfter");
              const colspanAfter = num_rows - current_row;
              offsetAfter.setAttribute("colspan", colspanAfter);
              if (colspanAfter > 0) {
                row.appendChild(offsetAfter);
              }
              body.appendChild(row);
            }
            originalBody.innerHTML = body.innerHTML;
          }
        </script>
        second part: eliminate hazards (other than load-use) by forwarding<br />



        third part: show limits of forwarding (not possible for load-use hazards
        since ALU needs it before it is loaded from mem) and reorder/schedule to
        solve load-use hazards <br />
        FINAL COMPARISON OF ALL VERSIONS AND COMBINATIONS
      </div>
    </div>
    <footer>
      <p>Copyright &#169; 2024 <a href="/">My Site</a></p>
    </footer>
  </body>
</html>
